<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Point Cloud - TouchDesigner Style</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Helvetica Neue', Arial, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI ë ˆì´ì•„ì›ƒ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        .glass-panel {
            pointer-events: auto;
            background: rgba(10, 10, 10, 0.7);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            display: inline-block;
            max-width: 250px;
        }

        h1 { 
            font-size: 14px; margin: 0 0 12px 0; 
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px; text-transform: uppercase; font-weight: 800;
        }
        p { font-size: 11px; color: #ccc; margin-bottom: 15px; line-height: 1.5; }
        
        input[type="file"] {
            font-size: 11px;
            width: 100%;
        }
        input[type="file"]::file-selector-button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #00d2ff;
            color: #000;
            border-color: #00d2ff;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>Neural Point Cloud</h1>
            <p>ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì—¬<br>GPU ê¸°ë°˜ íŒŒí‹°í´ ì•„íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”.</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
    </div>
    <div id="canvas-container"></div>

    <!-- Three.js ë° GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ (CDN) -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/+esm';

        // --- 1. GLSL Shaders (GPU í”„ë¡œê·¸ë¨) ---
        
        // Vertex Shader: ì ì˜ ìœ„ì¹˜ì™€ í¬ê¸°, ì™œê³¡ì„ ê³„ì‚°
        const vertexShader = `
            uniform sampler2D uTexture;
            uniform float uTime;
            uniform float uDisplacement;
            uniform float uNoiseSpeed;
            uniform float uNoiseFreq;
            uniform float uNoiseAmp;
            uniform float uDistortion;
            uniform float uSize;
            
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // í…ìŠ¤ì²˜ UV ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
                vec2 uv = uv;
                
                // ì´ë¯¸ì§€ ìƒ‰ìƒ ë° ë°ê¸° ìƒ˜í”Œë§
                vec4 texColor = texture2D(uTexture, uv);
                float brightness = (texColor.r + texColor.g + texColor.b) / 3.0;

                // ê¸°ë³¸ ìœ„ì¹˜
                vec3 pos = position;

                // 1. Distortion (ì´ë¯¸ì§€ ì™œê³¡ íš¨ê³¼)
                // ë°ê¸°ì— ë”°ë¼ Xì¶•ì„ ë¹„í‹€ì–´ íë¥´ëŠ” ë“¯í•œ ëŠë‚Œ ì—°ì¶œ
                pos.x += sin(uv.y * 10.0 + uTime * 0.5) * uDistortion * brightness;
                pos.y += cos(uv.x * 10.0 + uTime * 0.5) * uDistortion * brightness;

                // 2. Displacement (ë†’ì´ ë§µ)
                // ë°ì„ìˆ˜ë¡ ìœ„ë¡œ ì†Ÿì•„ì˜¤ë¦„
                float zOffset = brightness * uDisplacement;

                // 3. Noise (íŒŒë„ ì›€ì§ì„)
                float wave = sin(pos.x * uNoiseFreq + uTime * uNoiseSpeed) 
                           + cos(pos.y * uNoiseFreq + uTime * uNoiseSpeed);
                pos.z += zOffset + (wave * uNoiseAmp);

                // ìµœì¢… ìœ„ì¹˜ ê³„ì‚°
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // íŒŒí‹°í´ í¬ê¸° (ê±°ë¦¬ ì›ê·¼ê° ì ìš©)
                gl_PointSize = uSize * (300.0 / -mvPosition.z);

                // Fragment Shaderë¡œ ë°ì´í„° ì „ë‹¬
                vColor = texColor.rgb;
                vAlpha = brightness; // ì–´ë‘ìš´ ë¶€ë¶„ì€ íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´
            }
        `;

        // Fragment Shader: ì ì˜ ëª¨ì–‘(ì›í˜•)ê³¼ ìƒ‰ìƒ ê²°ì •
        const fragmentShader = `
            uniform vec3 uColorTint;
            uniform float uBrightnessMult;
            
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // Neural Style: ì›í˜• ì…ì ë§Œë“¤ê¸°
                // ì¤‘ì‹¬ì—ì„œ ê±°ë¦¬ê°€ 0.5 ì´ìƒì´ë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ (ì‚¬ê°í˜• -> ì›)
                vec2 coord = gl_PointCoord - vec2(0.5);
                if(length(coord) > 0.5) discard;

                // ë„ˆë¬´ ì–´ë‘ìš´ í”½ì…€(ë°°ê²½)ì€ ìˆ¨ê¹€ ì²˜ë¦¬
                if(vAlpha < 0.1) discard;

                // ìµœì¢… ìƒ‰ìƒ = ì›ë³¸ìƒ‰ * í‹´íŠ¸ * ë°ê¸° ì¡°ì ˆ
                vec3 finalColor = vColor * uColorTint * uBrightnessMult;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- 2. Three.js ê¸°ë³¸ ì„¤ì • ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202); // ë”¥ ë¸”ë™
        scene.fog = new THREE.FogExp2(0x020202, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 100, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 3. ì»¨íŠ¸ë¡¤ ë³€ìˆ˜ ë° GUI ---
        const params = {
            // Physics & Wave
            displacement: 120.0,
            noiseSpeed: 0.8,
            noiseFreq: 0.02,
            noiseAmp: 10.0,
            
            // Image Control
            size: 2.0,            // ì…ì í¬ê¸°
            distortion: 0.0,      // ì™œê³¡ ì •ë„
            brightness: 1.5,      // ë°ê¸° ë¶€ìŠ¤íŠ¸
            color: 0xffffff,      // ì»¬ëŸ¬ í‹´íŠ¸
        };

        let particles;
        let material;
        
        const gui = new GUI({ title: 'Controller' });
        
        // Group 1: Physics (Wave & Form)
        const folderPhysics = gui.addFolder('ğŸŒŠ Wave & Physics');
        folderPhysics.add(params, 'displacement', 0, 400).name('Displacement');
        folderPhysics.add(params, 'noiseSpeed', 0, 3).name('Noise Speed');
        folderPhysics.add(params, 'noiseFreq', 0.001, 0.1).name('Noise Freq');
        folderPhysics.add(params, 'noiseAmp', 0, 50).name('Noise Amp');
        
        // Group 2: Image Control (Visual Style)
        const folderImage = gui.addFolder('ğŸ¨ Image Control');
        folderImage.add(params, 'size', 0.1, 10.0).name('Particle Size');
        folderImage.add(params, 'distortion', 0, 50.0).name('Distortion'); // ì™œê³¡ ìŠ¬ë¼ì´ë”
        folderImage.add(params, 'brightness', 0, 5.0).name('Bright');      // ë°ê¸° ìŠ¬ë¼ì´ë”
        folderImage.addColor(params, 'color').name('Color Tint');          // ì»¬ëŸ¬ í”¼ì»¤
        
        folderPhysics.open();
        folderImage.open();

        // --- 4. ì´ë¯¸ì§€ ì²˜ë¦¬ ë° íŒŒí‹°í´ ìƒì„± ---
        function processImage(image) {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }

            // ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ í…ìŠ¤ì²˜ë¡œ ë³€í™˜
            const texture = new THREE.Texture(image);
            texture.needsUpdate = true;

            // ì„±ëŠ¥ì„ ìœ„í•´ ë¦¬ì‚¬ì´ì§• (ë„ˆë¬´ í° ì´ë¯¸ì§€ëŠ” ì ì´ ë„ˆë¬´ ë§ì•„ì§)
            const w = 400; // í•´ìƒë„ (ê°€ë¡œ ì  ê°œìˆ˜)
            const h = Math.floor(image.height * (w / image.width));
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const uvs = [];

            // Grid í˜•íƒœë¡œ ì  ë°°ì¹˜
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì¢Œí‘œ ê³„ì‚°
                    const posX = (x - w / 2) * 1.5; // ê°„ê²© ì¡°ì •
                    const posY = (y - h / 2) * 1.5;
                    
                    positions.push(posX, posY, 0);
                    
                    // UV ì¢Œí‘œ (0~1 ì‚¬ì´ ê°’ìœ¼ë¡œ ì •ê·œí™”) -> í…ìŠ¤ì²˜ ë§¤í•‘ìš©
                    uvs.push(x / w, 1.0 - (y / h)); // Yì¶• ë°˜ì „
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

            // ShaderMaterial ìƒì„± (Uniforms ì—°ê²°)
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: texture },
                    uTime: { value: 0 },
                    uDisplacement: { value: params.displacement },
                    uNoiseSpeed: { value: params.noiseSpeed },
                    uNoiseFreq: { value: params.noiseFreq },
                    uNoiseAmp: { value: params.noiseAmp },
                    uDistortion: { value: params.distortion },
                    uSize: { value: params.size },
                    uBrightnessMult: { value: params.brightness },
                    uColorTint: { value: new THREE.Color(params.color) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // ë¹›ì´ ê²¹ì¹˜ë©´ ë°ì•„ì§€ëŠ” íš¨ê³¼
            });

            particles = new THREE.Points(geometry, material);
            
            // ì´ˆê¸° íšŒì „ (ë°”ë‹¥ì— ëˆ„ìš´ í˜•íƒœê°€ ì•„ë‹ˆë¼ ì •ë©´ì„ ë³´ê±°ë‚˜ ì‚´ì§ ê¸°ìš¸ì„)
            particles.rotation.x = -Math.PI / 4; 
            
            scene.add(particles);
        }

        // --- 5. íŒŒì¼ ì—…ë¡œë“œ í•¸ë“¤ë§ ---
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => processImage(img);
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // --- 6. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (particles && material) {
                // Uniforms ê°’ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
                material.uniforms.uTime.value = time;
                material.uniforms.uDisplacement.value = params.displacement;
                material.uniforms.uNoiseSpeed.value = params.noiseSpeed;
                material.uniforms.uNoiseFreq.value = params.noiseFreq;
                material.uniforms.uNoiseAmp.value = params.noiseAmp;
                
                material.uniforms.uSize.value = params.size;
                material.uniforms.uDistortion.value = params.distortion;
                material.uniforms.uBrightnessMult.value = params.brightness;
                material.uniforms.uColorTint.value.setHex(params.color);
                
                // ì „ì²´ ì˜¤ë¸Œì íŠ¸ ì²œì²œíˆ íšŒì „
                particles.rotation.z = Math.sin(time * 0.1) * 0.05;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>